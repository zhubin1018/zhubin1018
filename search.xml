<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx</title>
    <url>/2020/03/06/Nginx/</url>
    <content><![CDATA[<h1 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h1><p>&#160; &#160; &#160; &#160; Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。<br>&#160; &#160; &#160; &#160; 其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。<br>&#160; &#160; &#160; &#160; Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。<br>&#160; &#160; &#160; &#160; Nginx专门为性能优化而开发，占内存少，并发能力强，能经受高负载的考验，支持高达50 000个并发连接数。</p>
<a id="more"></a>

<h1 id="下载Nginx"><a href="#下载Nginx" class="headerlink" title="下载Nginx"></a>下载Nginx</h1><p>&#160; &#160; &#160; &#160; <strong>nginx.org官网下载<a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a></strong><br>&#160; &#160; &#160; &#160; 安装前准备 : 安装nginx需要的库<br>&#160; &#160; &#160; &#160; 安装gcc，nginx需要先将官网上下载的源码进行编译，编译需要依赖gcc环境。<code>yum install gcc-c++</code><br>&#160; &#160; &#160; &#160; 安装PCRE，PCRE是一个Perl库，包括了perl兼容的正则表达式库。nginx的http模板使用pcre来解析正则表达式。<code>yum install -y pcre pcre-devel</code><br>&#160; &#160; &#160; &#160; zlib库提供了很多种压缩解压的方式，nginx使用zlib对http包的内容进行gzlib,所以需要zlib库。<code>yum install -y zlib zlib-devel</code><br>&#160; &#160; &#160; &#160; OpenSSL是一个强大的安全套接字层密码库。 囊括主要的密码算法，常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其他目的使用。nginx不仅支持http协议，还支持https,所以需要安装openssl库。<code>yum install  -y openssl openssl-devel</code><br>&#160; &#160; &#160; &#160; 正式安装Nginx<br>&#160; &#160; &#160; &#160; 1.解压Nginx <code>tar -zxvf nginx-1.16.1.tar.gz</code><br>&#160; &#160; &#160; &#160; 2.切换到解压后的文件中 <code>cd nginx-1.16.1</code><br>&#160; &#160; &#160; &#160; 3.指定安装目录<code>./configure --prefix=/usr/local/java/nginx</code><br>&#160; &#160; &#160; &#160; 4.还是在/opt/nginx-1.16.1目录下执行编译<code>make</code><br>&#160; &#160; &#160; &#160; 5.继续执行<code>make install</code><br>&#160; &#160; &#160; &#160; 6.启动nginx <code>cd /usr/local/java/nginx/sbin</code>中启动<code>./nginx</code><br>&#160; &#160; &#160; &#160; 7.查看进程,有Nginx的master进程和worker进程说明启动成功 <strong>ps -ef | grep nginx</strong>，Nginx体系主要包括master和worker两大进程，master进程读取配置文件,并维护worker进程,而worker进程则对请求进行实际处理;<br>&#160; &#160; &#160; &#160; 8.关闭：<code>./nginx -s stop</code><br>&#160; &#160; &#160; &#160; 8.重启：<code>./nginx -s reload</code></p>
<h1 id="Nginx配置文件nginx-conf"><a href="#Nginx配置文件nginx-conf" class="headerlink" title="Nginx配置文件nginx.conf"></a>Nginx配置文件nginx.conf</h1><p><strong>more nginx.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;基本配置&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#user  nobody;      #表示当前配置的权限，一般为root</span><br><span class="line">worker_processes  1;    #配置工作进程数目,根据硬件调整,通常等于CPU数量或者2倍于CPU数量</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log; #配置全局错误日志及类型,[debug | info | notice | warn | error |crit]默认是error</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;     #配置进程pid文件</span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;配置工作模式和连接数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;   #配置每个worker进程连接数上限,nginx支持的总连接数就等于worker_process * worker_connections</span><br><span class="line">&#125;</span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;配置http服务器,利用它的反向代理功能提供负载均衡支持&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   #配置nginx支持哪些多媒体类型,可以在conf&#x2F;mime.types查看支持哪些多媒体类型;</span><br><span class="line">    default_type  application&#x2F;octet-stream;     #默认文件类型;</span><br><span class="line"></span><br><span class="line">    #配置日志格式 </span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">    </span><br><span class="line">    #配置access.log日志及存放路径,并使用上面定义的main日志格式</span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;     #开启高效文件传输模式;</span><br><span class="line">    #tcp_nopush     on;     #防止网络阻塞;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;  #长连接超时时间,单位是秒</span><br><span class="line"></span><br><span class="line">    #gzip  on; #开启gzip压缩输出</span><br><span class="line">    </span><br><span class="line">###--------------------------------------------------------------------------------------------</span><br><span class="line"> </span><br><span class="line"> #多个sever配置</span><br><span class="line">   </span><br><span class="line">   #配置虚拟主机</span><br><span class="line">   server &#123;</span><br><span class="line">        listen       80;    #配置监听端口</span><br><span class="line">        server_name  localhost; #配置服务名</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;    #配置字符集</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main; #配置本虚拟主机的访问日志</span><br><span class="line">        </span><br><span class="line">        #默认的&#x2F;请求,当访问路径中有斜杆&#x2F;,会被location匹配到并进行处理</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html; #root是配置服务器的默认网站根目录位置,默认为nginx安装主目录下的html目录</span><br><span class="line">            index  index.html index.htm; #配置首页文件名称</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #PHP 脚本请求全部转发到Apache处理</span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line">        </span><br><span class="line">        #PHP脚本请求全部转发到FastCGI处理</span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line">          </span><br><span class="line">         #禁止访问.htaccess文件 </span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     #配置另一个虚拟主机</span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    #配置https服务,安全网络传输协议,加密传输,端口443,运维来配置</span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Nginx静态网站"><a href="#Nginx静态网站" class="headerlink" title="Nginx静态网站"></a>Nginx静态网站</h2><blockquote>
<p>Nginx是一个HTTP的web服务器.可以将服务器上静态文件通过HTTP协议返回给浏览器客户端;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">            root  &#x2F;optstatic&#x2F;传输上去的静态文件;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><h2 id="Nginx正向代理"><a href="#Nginx正向代理" class="headerlink" title="Nginx正向代理"></a>Nginx正向代理</h2><blockquote>
<p>把局域网外的Internet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。<br>正向代理架设在客户机与目标主机之间，只用于代理内部网络对Internet的连接请求；正向代理代理的是客户端 ;</p>
</blockquote>
<h2 id="Nginx反向代理-1"><a href="#Nginx反向代理-1" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><blockquote>
<p>客户端对反向代理是无感知的，因为客户端不需要任何配置就能访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器就是一个服务器，暴露的代理服务器地址隐藏了真实服务器的IP地址。<br>反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量；反向代理代理的是服务端 ;<br>使用方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.123.com;#访问域名</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;#被代理服务器的地址。可以是主机名称、IP地址加端口号的形式。</span><br><span class="line">            index  index.html index.htm index.jsp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><blockquote>
<p>单个服务器解决不了,我们增加服务器的数量,然后将请求分发到各个服务器上,将原来请求集中单个服务器的情况改为分发到对个服务器上,将负载发布到多个的服务器,也就是我们说的<strong>负责均衡</strong>;</p>
</blockquote>
<ul>
<li><p><strong>硬件</strong></p>
<blockquote>
<p>比如 : F5, 深信服 .Arry等;<br>优点,厂商专业的技术团队提供支持,性能稳定;<br>缺点:费用昂贵,对规模较小的网络应用成本较高;</p>
</blockquote>
</li>
<li><p><strong>软件</strong></p>
<blockquote>
<p>比如 : Nginx , LVS , HAProxy等;<br>免费开源,成本低廉;</p>
</blockquote>
</li>
<li><p><strong>通过Nginx的nginx.conf文件实现负载均衡</strong><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200307002852.png" alt=""></p>
<p><strong>使用方法</strong><br><strong>配置2步</strong><br>1.在http模块加上:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream www.bin1018.com&#123;</span><br><span class="line">               server 127.123.123.168:8080 weight &#x3D; 3;</span><br><span class="line">               server 127.123.123.168:8081 weight &#x3D; 1;</span><br><span class="line">               ip_hash;</span><br><span class="line">               &#125;</span><br><span class="line"> #weight表示权重,用于后端服务器性能不均的情况,访问比率等于权重之比,权重越大访问机会越多;</span><br><span class="line"> #upstream是配置nginx非常重要的一个模块,并且它还能对后端的服务器的健康状况进行检查,若后端服务器中一台发生故障,则前端请求不会转发到该故障服务器上;</span><br><span class="line"># ip_hash;一种IP的算法，只要用户使用同一个IP请求，nginx会分流到之前请求的服务器，解决session登录的配置问题。</span><br></pre></td></tr></table></figure>
<p>2.在server模块里添加 : (举例)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;myweb &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;www.bin1018.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<a href="http://www.bin1018.com字符串要和upstream后面的字符串相等" target="_blank" rel="noopener">www.bin1018.com字符串要和upstream后面的字符串相等</a>;<br>ps:这两个字符串写什么无所谓,只要保证相等,写域名主要是因为可读性高;</p>
<h1 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h1><blockquote>
<p>为了加快网站的解析速度.可以把动态页面和静态页面由不同的服务器解析,加快解析速度;降低原来单个服务器的压力;</p>
</blockquote>
<p><strong>使用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  root;</span><br><span class="line">#将之前默认的#user  nobody;进行以上修改，获取访问静态资源的权限   </span><br><span class="line">location ~*\.(css|js|html|png) &#123;</span><br><span class="line">    root &#x2F;usr&#x2F;resources;</span><br><span class="line">    #&#x2F;usr&#x2F;resources是存放的静态资源文件的绝对路径。</span><br><span class="line">    expires 7d;</span><br><span class="line">    #有效天数。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps：上面用到了正则表达式，默认css等静态资源将再静态资源文件中获取。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>PicGo</title>
    <url>/2020/03/06/PicGo/</url>
    <content><![CDATA[<p>&#160; &#160; &#160; &#160; 对于很多程序员来说都有写博客的习惯，之前一直喜欢用印象笔记来写东西然后发布到自己的CSDN账号。不过发现一个问题，印象笔记生成的图片链接到CSDN上无法使用，显示私密链接。而且很多程序员都有自己的个人博客，对于博客来说不可避免有不少图片，会严重影响博客的加载速度，于是很多程序员都喜欢用图床技术。<br>&#160; &#160; &#160; &#160; 为了解决这个问题，可以把自己图片放到图床上去，这样就可以共用。可以直接在聚合图床：<a href="https://www.superbed.cn" target="_blank" rel="noopener">https://www.superbed.cn</a>，上传自己的图片获得链接。可是有弊端，链接可能会失效，之前阅读别人博客，会发现很多博客图片失效。对于程序员来说博客图片必不可少，若多年前文章中图片链接突然失效，很难恢复，因为自己很难记得这些图的内容了。当然聚合图床的会员可以避免这种情况。很贵，不推荐。求人不如求己，我们可以用github构造一个图床，由于github外网的原因，图片加载会很慢，github能做到的事情码云肯定可以做，说了这么多，现在就讲如何用PicGo+码云来构建自己的图床。所有操作之前先在自己电脑内下载node.js。</p>
<a id="more"></a>

<ul>
<li><p>下载PicGo：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a>下载匹配自己电脑的版本，这里我下的Windows版本。<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200306124226.png" alt=""></p>
</li>
<li><p>在PicGo中搜索gitee插件并安装。<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200306124604.png" alt=""></p>
</li>
<li><p>在码云中创建一个新厂库来保存图片</p>
</li>
</ul>
<p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200306124907.png" alt=""></p>
<ul>
<li>创建完选择去设置</li>
</ul>
<p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200306125059.png" alt=""></p>
<ul>
<li>点击私人令牌</li>
</ul>
<p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200306125309.png" alt=""></p>
<ul>
<li>创建新的令牌，后勾选project即可提交</li>
</ul>
<p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200306125412.png" alt=""></p>
<ul>
<li>此时会生成一个token注意保存，只会显示一次。</li>
<li>如下图设置PicGo即可。<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200306125716.png" alt=""></li>
</ul>
<p>ps；一些坑，在这里使用PicGo作者出现了剪切板上传出现警告，你可能没有，我把我的解决办法奉上：</p>
<ol>
<li>找到powershell路径</li>
</ol>
<p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200306130704.png" alt=""></p>
<ol start="2">
<li>在环境变量中path添加powershell路径已经piggo的相关配置</li>
</ol>
<p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200306130902.png" alt=""></p>
<p>3.重启电脑，后就可以使用自己的图床了。 </p>
]]></content>
      <categories>
        <category>图床</category>
      </categories>
      <tags>
        <tag>PicGo</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2020/03/02/Redis/</url>
    <content><![CDATA[<h1 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a>NoSql</h1><p>&#160; &#160; &#160; &#160;Redis属于NoSql里面的一个具体的技术</p>
<h2 id="NoSql入门和概述"><a href="#NoSql入门和概述" class="headerlink" title="NoSql入门和概述"></a>NoSql入门和概述</h2><p>&#160; &#160;<strong>入门概述</strong></p>
<p>&#160; &#160; &#160; &#160;在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。在那个时候，更多的都是静态网页，动态交互类型的网站不多。随着现在互联网用户剧增, 如果同时大量语句进行, MySQL将无法应付。数据量的剧增,会存在一个机器放不下, 数据的索引也存放不下。同时访问量的增加, MySQL就开始出现性能问题。为了提高性能, 开始利用缓存, 减少MySQL性能消耗。</p>
<a id="more"></a>
<p>&#160; &#160; &#160; &#160;但随着访问量持续增大，多台机器之间缓存无法共享，大量的小文件缓冲也会带来比较高的IO压力。此时Memcached自然的成为了一个时尚的产品。它解决了多台机器数据共用问题。Memcached(缓存)+MySQL+垂直拆分技术的出现，来进行主从分离，就出现了分表分库提高性能。随着访问量继续增长，分表分库+水平拆分+mysql集群。但MySQL存储大文件时，在做数据库恢复时特别慢，大数据下它表现出的扩展性差，表结构更加困难。</p>
<p>&#160; &#160; &#160; &#160;当今互联网架构图：<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200303141740.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;为什么要用NoSql?<br>&#160; &#160; &#160; &#160;今天我们可以通过第三方平台可以很容易的访问和抓取数据。用户的个人信息，网络地址，操作日志 成倍增加，如果我们要对这些用户数据进行挖掘，那么SQL数据库已经不适合这些应用了。NoSQL数据库的发展能很好的处理这些数据。</p>
<p>&#160; &#160; &#160; &#160;什么是NoSql？<br>&#160; &#160; &#160; &#160;<u>NoSql=Not Only SQL</u>，不仅仅是SQL，泛指<u>非关系形数据库</u>，解决大规模数据集合，多重数据种类带来的挑战。</p>
<p>&#160; &#160; &#160; &#160;NoSql能干嘛？<br>&#160; &#160; &#160; &#160;易扩展，去掉关系型数据库的关系型特性，数据之间无关系，非常容易扩展；大数据量高性能，每一秒中支持11万次读，8万次写。大数量下表现优异，符合当今互联网时代下的发展；多样灵活的数据模型，随时储存自定义的数据类型。对应KV键值对，Cashe缓存型数据库,Persistence持久性。</p>
<p>&#160;&#160; &#160; &#160;NoSql对应的三个产品：<br>&#160;&#160; &#160; &#160; Redis | memecache | Mongdb</p>
<h2 id="NoSql-3V-3高"><a href="#NoSql-3V-3高" class="headerlink" title="NoSql 3V + 3高"></a><strong>NoSql 3V + 3高</strong></h2><p>&#160; &#160; &#160; &#160;大数据时代的3V：<br>&#160; &#160; &#160; &#160;海量Volume | 多样Variety | 实时Velocity<br>&#160; &#160; &#160; &#160;互联网需求的3高：<br>&#160; &#160; &#160; &#160;高并发 | 高可扩 | 高性能</p>
<h2 id="当下NoSql的经典应用"><a href="#当下NoSql的经典应用" class="headerlink" title="当下NoSql的经典应用"></a><strong>当下NoSql的经典应用</strong></h2><p>&#160; &#160; &#160; &#160; 当下的应用是sql和nosql一起使用的。</p>
<p>&#160; &#160; &#160; &#160; NoSql经典应用：</p>
<p>&#160; &#160; &#160; &#160; 阿里巴巴技术演变图:<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200303155442.png" alt=""></p>
<p>&#160; &#160; &#160; &#160; 阿里巴巴中文网:</p>
<p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200303155136.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200303155257.png" alt=""></p>
<h2 id="NoSQL数据模型简介"><a href="#NoSQL数据模型简介" class="headerlink" title="NoSQL数据模型简介"></a><strong>NoSQL数据模型简介</strong></h2><p>&#160; &#160; &#160; &#160; 聚合模型<br>&#160; &#160; &#160; &#160; KV键值；bson；列族（顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。）；图形。</p>
<h2 id="NoSQL数据库的四大分类"><a href="#NoSQL数据库的四大分类" class="headerlink" title="NoSQL数据库的四大分类"></a><strong>NoSQL数据库的四大分类</strong></h2><p>&#160; &#160; &#160; &#160; KV键值：<br>典型介绍<br>新浪：BerkeleyDB+redis | 美团：redis+tair | 阿里、百度：memcache+redis</p>
<p>&#160; &#160; &#160; &#160; 文档型数据库(bson格式比较多)：<br>典型介绍<br>CouchDB | MongoDB（是一个基于分布式文件存储的数据库一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。）</p>
<p>&#160; &#160; &#160; &#160; 列存储数据库<br>Cassandra, HBase | 分布式文件系统</p>
<p>&#160; &#160; &#160; &#160; 图关系数据库<br>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统 ；社交网络，推荐系统等。专注于构建关系图谱;代表有：Neo4J, InfoGrid。</p>
<h2 id="在分布式数据库中CAP原理CAP-BASE"><a href="#在分布式数据库中CAP原理CAP-BASE" class="headerlink" title="在分布式数据库中CAP原理CAP+BASE"></a><strong>在分布式数据库中CAP原理CAP+BASE</strong></h2><p>&#160; &#160; &#160; &#160; 传统的ACID分别是什么？</p>
<blockquote>
<p>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：<br>1、A (Atomicity) 原子性原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。<br>2、C (Consistency) 一致性一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>3、I (Isolation) 独立性所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的<br>4、D (Durability) 持久性持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; <strong>CAP</strong><br>&#160; &#160; &#160; &#160; C: Consistency（强一致性）<br>&#160; &#160; &#160; &#160; A: Availability（高可用性）<br>&#160; &#160; &#160; &#160; P:Partition tolerance（分区容错性）</p>
<p>&#160; &#160; &#160; &#160; CAP3选2<br>&#160; &#160; &#160; &#160;<br>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡。</p>
<p>CA 传统Oracle数据库 |  AP 大多数网站架构的选择 |  CP Redis、Mongodb</p>
<p>一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P，这是目前分布式数据库产品的方向</p>
<p>&#160; &#160; &#160; &#160; <strong>BASE</strong><br>&#160; &#160; &#160; &#160; BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。<br>&#160; &#160; &#160; &#160; BASE其实是下面三个术语的缩写：<br>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 基本可用（Basically Available）<br>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 软状态（Soft state）<br>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 最终一致（Eventually consistent</p>
<p>&#160; &#160; &#160; &#160; <strong>分布式+集群简介</strong></p>
<blockquote>
<p>分布式系统（distributed system） 由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。<br>简单来讲：<br>1分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。<br>2集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。</p>
</blockquote>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis入门介绍"><a href="#Redis入门介绍" class="headerlink" title="Redis入门介绍"></a>Redis入门介绍</h2><p>&#160; &#160; &#160; &#160; <strong>入门概述</strong></p>
<p>&#160; &#160; &#160; &#160; Redis:REmote DIctionary Server(远程字典服务器)<br>&#160; &#160; &#160; &#160; 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。</p>
<p>&#160; &#160; &#160; &#160; Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<blockquote>
<p>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储；<br>Redis支持数据的备份，即master-slave模式的数据备份；</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; Redis能干嘛?<br>&#160; &#160; &#160; &#160; 内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务；取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面；模拟类似于HttpSession这种需要设定过期时间的功能；发布、订阅消息系统；定时器、计数器；</p>
<h3 id="安装并编写HelloWorld"><a href="#安装并编写HelloWorld" class="headerlink" title="安装并编写HelloWorld"></a>安装并编写HelloWorld</h3><blockquote>
<p>官方下载网站：<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a>(99%安装在Linux中)<br>下载完压缩包传到 /opt文件夹中<br>解压后存入 /usr/local/java 中<br>进入Redis中 cd redis-3.0.4/<br>安装gcc yum install gcc-c++<br>执行 make distclean之后执行make<br>执行安装 make install<br>查看默认安装目录 cd /usr/local/bin<br>ls-l 查看如下<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304013652.png" alt=""><br>执行 cd /usr/local/java/redis-3.0.4/<br>找到一个 redis.conf<br>执行 mkdir /myRedis/<br>执行 cp redis.conf /myRedis/<br>执行 vim /myRedis/redis.conf/<br>修改 daemonize no 为 daemonize yes (使redis能在后台的方式运行)<br>编写Redis的HelloWorld<br>查看redis是否启动 ps -ef | grep redis<br><strong>运行redis</strong> redis-server /myRedis/redis.conf (建议在redis安装目录下启动，/usr/local/bin/)<br><strong>进入redis</strong> redis-cli -p 6379<br>set k1 HelloWorld<br>回复ok表示设置成功<br>get k1 可得到值HelloWorld</p>
</blockquote>
<h3 id="Redis启动后杂项基础知识"><a href="#Redis启动后杂项基础知识" class="headerlink" title="Redis启动后杂项基础知识"></a>Redis启动后杂项基础知识</h3><p>Redis是单线程的</p>
<blockquote>
<p>单进程模型来处理客户端的请求。对读写等事件的响应是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率</p>
</blockquote>
<p>Redis默认16个数据库：</p>
<blockquote>
<p>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id  </p>
</blockquote>
<p>查看库中数据条数</p>
<blockquote>
<p>dbsize</p>
</blockquote>
<p>查看所有key</p>
<blockquote>
<p>keys *</p>
</blockquote>
<p>清空当前库</p>
<blockquote>
<p>flushdb1</p>
</blockquote>
<p>清空所有库</p>
<blockquote>
<p>flushall</p>
</blockquote>
<p>Redis默认端口号</p>
<blockquote>
<p>6379</p>
</blockquote>
<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>&#160; &#160; &#160; &#160; 可在官方文档中查看数据类型：<a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">https://redis.io/topics/data-types-intro</a><br>&#160; &#160; &#160; &#160; 中文网址：<a href="http://redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="noopener">http://redis.cn/topics/data-types-intro.html#strings</a></p>
<h3 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h3><blockquote>
<p>String（字符串）string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M。<br>Hash（哈希）Redis hash 是一个键值对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;<br>List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个链表。<br>Set（集合）Redis的Set是string类型的无序集合。它是通过HashTable实现实现的。<br>zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
</blockquote>
<h3 id="key常用指令"><a href="#key常用指令" class="headerlink" title="key常用指令"></a>key常用指令</h3><p>&#160; &#160; &#160; &#160; 查看Redis常用操作命令：<a href="http://redisdoc.com/" target="_blank" rel="noopener">http://redisdoc.com/</a></p>
<p><code>keys *</code> ：查看当前库的所有key。<br><code>exists key</code> ：判断某个key是否存在。<br><code>move key db</code>：移除键到指定数据库。<br><code>expire key 秒钟</code>：为key设置过期时间。（已经过期的key实际被移除，无法再设置时间）<br><code>ttl key</code>：查看还有多少秒过期，-1为永远不过期，-2为已过期。<br><code>type key</code>：查看你的可以是什么类型。<br><code>del key</code>：删除key。</p>
<h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><p><code>strlen key</code>：获取key对应value的长度。<br><code>incr key</code>：自增key的值，一定要是数字。<br><code>decr key</code>：自减key的值，一定要是数字。<br><code>incrby key num</code>：指定key的值增长指定数。<br><code>getrange key start_num end_num</code>：获取key中value指定字段，当数字为正数就是在前面获取（起始值为0），当数字为负数就在后面获取（-1表示最后一个值）。如图：<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304133927.png" alt=""><br><code>setrange key start_num new_value</code>：替换key中value，从第start_num开始，new_value有多长就会替换start_num及其后几位的value。如图：<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304134446.png" alt=""><br><code>setex key time value</code>：（set with expire）设置键为key的value，并设置过期时间为time。<br><code>setnx key value</code>：（set if not exist）设置键为key，值为value，若该key本身存在设置失败返回0。<br><code>mset k1 v1 k2 v2 k3 v3 ...</code>：批量设置键值对。<br><code>mget k1 k2 k3 ...</code>：批量获取。<br><code>msetnx k1 v11 k4 v4 k5 v5 ...</code>：批量判断设置，若其中一个值已经存在，所有的都会设置失败。<br><code>getset key value</code>：先get获取，在set设置，如图<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304140423.png" alt=""></p>
<h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><blockquote>
<p>单值多value</p>
</blockquote>
<p><code>lpush mylist 1 2 3 4 5</code>：左边插入。<br><code>lrange mylist start_num end_num</code>：读取左边的value ，start_num开始，end_num结束。（-1表示最后一位）。如图：<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304143623.png" alt=""><br><code>rpush mylist 6 7 8 9</code>：右边插入。<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304144019.png" alt=""><br><code>lpop mylist</code>：删除mylist中最左边的值。<br><code>rpop mylist</code>：：删除mylist中最右边的值。<br><code>lindex mylist num</code>：同过索引获得元素值。<br><code>llen mylist</code> ：获取mylist长度。<br><code>lrem mylist num value</code>：指定key中删除num个值为value的元素。<br><code>ltrim key start_index end_index</code>截取指定范围的值重新再赋值给key。<br><code>rpoplpush mylist01 mylist02</code>；删除mylist01最右边的值添加到mylist02的最左边。<br><code>lset mylist index value</code>：设置mylist中索引为index的值为value。<br><code>linsert mylist before/after v1 v2</code> ：在mylist中的v1之前或之后插入v2。</p>
<h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><blockquote>
<p>单值多value</p>
</blockquote>
<p><code>sadd set01 v1 v2 v3 v4</code> :set添加剂多个value，他可以自动去掉重复值(他是无序的)。<br><code>smembers set01</code>：查看set。<br><code>sismember set01 v1</code>：查看set中是否有v1,有的话返回1，没有返回0。<br><code>scard set01</code>：获取set中元素个数。<br><code>srem seto1 value</code>：删除集合中的元素。<br><code>srandmember set01 num</code>：在set01中随机取num个值。<br><code>spop set01</code>：随机出栈。<br><code>smove set01 set02 set01_v</code>：随机移动set01中的set_v到set02中。</p>
<h4 id="数学集合类"><a href="#数学集合类" class="headerlink" title="数学集合类"></a>数学集合类</h4><p><code>sdiff set01 set02</code>：差集</p>
<p><code>sinter set01 set02</code>：交集</p>
<p><code>sunion set01 set02</code>：并集</p>
<h3 id="哈希（Hash）"><a href="#哈希（Hash）" class="headerlink" title="哈希（Hash）"></a>哈希（Hash）</h3><blockquote>
<p>kv模式不变，但v是一个键值对</p>
</blockquote>
<p><code>hset hash01 name tom</code>：添加hash。<br><code>hget hash01 name</code>：获取hash01中的name键值对的值。<br><code>hmset hash01 name tom sex 男 age 18</code>：批量在hash01中添加键值对。<br><code>hmget hash01 name sex age</code>：批量获取hash01中键值对的值。<br><code>hgetall hash01</code>：获取hash01中所有键和值。<br><code>hdel hash01 name</code>：指定hash中的键来删除键值对。<br><code>hlen hash01</code>：获取hash01中的键值对个数。<br><code>hexists hash01 name</code>：判断hash01中是否存在name的key。存在回1，不存在回0。<br><code>hkeys hash01</code>：获取hash01中所有key集合。<br><code>hvals hash01</code>：获取hash01中所有values集合。<br><code>hincrby hash01 age num</code>：指定hash01中的age加num。num是整数类型的数字。<br><code>hincrbyfloat hash01 salary float</code>：指定hash01中的salary加float。float是浮点型。<br><code>hsetnx hexo01 name tom</code>：不存在就赋值，存在就无效。</p>
<h3 id="有序集合Zset-sorted-set"><a href="#有序集合Zset-sorted-set" class="headerlink" title="有序集合Zset(sorted set)"></a>有序集合Zset(sorted set)</h3><blockquote>
<p>在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是k1 score1 v1 score2 v2</p>
</blockquote>
<p><code>zadd zset01 60 v1 70 v2 80 v3</code>：添加Zset。<br><code>zrange zset01 0 -1</code>：遍历所有的zset中的value。<br><code>zrange zset01 0 -1 withscores</code> 伴随分数遍历出来。<br><code>zrevrangebyscore  zseto1 60 80</code>遍历60分到80分中的值。<br><code>zrevrangebyscore  zseto1 60 80 withscores</code>：伴随分数遍历60 到 80之间的。<br><code>zrevrangebyscore  zseto1 60 （80</code>：遍历不包含80。<br><code>zrevrangebyscore  zseto1 60 80 limit tageNo size</code> ：从tageNo 往后查size个60 到 80 之间的value。<br><code>zrem zset01 v1</code>：删除某score下对应的value值，作用是删除元素。<br><code>zcard zset01</code>：查询zset01中元素个数。<br><code>zcount zset01 60 80</code>：根据范围查元素个数。<br><code>zrank zset01 value</code>：获取value下标的值。<br><code>zscore zset01 value</code>：获取value对应的score值。<br><code>zrevrank zset01 value</code>：反转后获取value下标。<br><code>zrevrange zset01 0 -1</code>：反转获取value。<br><code>zrevrange zset01 end_score start_score</code>：通过反转获取指定score范围的value。</p>
<h2 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h2><blockquote>
<p>可参考菜鸟教程看更详细说明：<a href="https://www.runoob.com/redis/redis-conf.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-conf.html</a></p>
</blockquote>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><blockquote>
<p>本身在/usr/local/java/redis-3.0.4下的 redis.conf，但配置尽量不去动最初的配置文件，用我们之前复制的配置文件。<br>去到配置所在目录  cd /myRedis/<br>进入配置文件 vim redis.conf </p>
</blockquote>
<h3 id="units单位"><a href="#units单位" class="headerlink" title="units单位"></a>units单位</h3><blockquote>
<p>1  配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>2  对大小写不敏感<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304173522.png" alt=""></p>
</blockquote>
<h3 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a>INCLUDES包含</h3><blockquote>
<p>和我们的Struts2配置文件类似，可以通过includes包含，redis.conf可以作为总闸，包含其他。<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304173917.png" alt=""></p>
</blockquote>
<h3 id="GENERAL通用"><a href="#GENERAL通用" class="headerlink" title="GENERAL通用"></a>GENERAL通用</h3><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304174432.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304174918.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304182136.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304182432.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304182633.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304182742.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304182925.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304183027.png" alt=""></p>
<h3 id="SNAPSHOTTING快照"><a href="#SNAPSHOTTING快照" class="headerlink" title="SNAPSHOTTING快照"></a>SNAPSHOTTING快照</h3><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304194237.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304194507.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304203054.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304203240.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304203430.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304203804.png" alt=""></p>
<h3 id="REPLICATION复制"><a href="#REPLICATION复制" class="headerlink" title="REPLICATION复制"></a>REPLICATION复制</h3><h3 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h3><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304184312.png" alt=""></p>
<h3 id="LIMITS限制"><a href="#LIMITS限制" class="headerlink" title="LIMITS限制"></a>LIMITS限制</h3><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304185001.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304185113.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304185552.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304190049.png" alt=""></p>
<h3 id="APPEND-ONLY-MODE追加"><a href="#APPEND-ONLY-MODE追加" class="headerlink" title="APPEND ONLY MODE追加"></a>APPEND ONLY MODE追加</h3><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305005700.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305005852.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305010224.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305015013.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305015538.png" alt=""></p>
<h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><blockquote>
<p>参数说明redis.conf 配置项说明如下：</p>
<ol>
<li>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程  daemonize no</li>
<li>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定  pidfile /var/run/redis.pid</li>
<li>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字  port 6379</li>
<li>绑定的主机地址  bind 127.0.0.1</li>
<li>当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能  timeout 300</li>
<li>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose  loglevel verbose</li>
<li>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null  logfile stdout</li>
<li>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id  databases 16</li>
<li>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合  save <seconds> <changes>  Redis默认配置文件中提供了三个条件：  save 900 1  save 300 10  save 60 10000  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 </li>
<li>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大  rdbcompression yes</li>
<li>指定本地数据库文件名，默认值为dump.rdb  dbfilename dump.rdb</li>
<li>指定本地数据库存放目录  dir ./</li>
<li>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步  slaveof <masterip> <masterport></li>
<li>当master服务设置了密码保护时，slav服务连接master的密码  masterauth <master-password></li>
<li>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭  requirepass foobared</li>
<li>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息  maxclients 128</li>
<li>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区  maxmemory <bytes></li>
<li>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no  appendonly no</li>
<li>指定更新日志文件名，默认为appendonly.aof   appendfilename appendonly.aof</li>
<li>指定更新日志条件，共有3个可选值：   no：表示等操作系统进行数据缓存同步到磁盘（快）   always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）   everysec：表示每秒同步一次（折衷，默认值）  appendfsync everysec </li>
<li>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）   vm-enabled no</li>
<li>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享   vm-swap-file /tmp/redis.swap</li>
<li>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0   vm-max-memory 0</li>
<li>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值   vm-page-size 32</li>
<li>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。   vm-pages 134217728</li>
<li>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4   vm-max-threads 4</li>
<li>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启  glueoutputbuf yes</li>
<li>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法  hash-max-zipmap-entries 64  hash-max-zipmap-value 512</li>
<li>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）  activerehashing yes</li>
<li>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件  include /path/to/local.conf</li>
</ol>
</blockquote>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><blockquote>
<p>redis持久化由RDB和AOF完成</p>
</blockquote>
<h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><h4 id="RDB是什么"><a href="#RDB是什么" class="headerlink" title="RDB是什么"></a>RDB是什么</h4><blockquote>
<p>在指定的时间间隔内,将内存中的数据及快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。<br>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方<br>式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
</blockquote>
<h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><blockquote>
<p>fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）<br>数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
</blockquote>
<h4 id="dump-rdb"><a href="#dump-rdb" class="headerlink" title="dump.rdb"></a>dump.rdb</h4><blockquote>
<p>rdb 保存的是dump.rdb文件<br>在 /usr/local/bin目录下保存</p>
</blockquote>
<h4 id="如何触发RDB快照"><a href="#如何触发RDB快照" class="headerlink" title="如何触发RDB快照"></a>如何触发RDB快照</h4><ul>
<li>配置文件中默认的快照配置</li>
<li>命令save或者是bgsave，来创建当前数据库的备份。该命令将在 redis 安装目录中创建dump.rdb文件。</li>
<li>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</li>
</ul>
<h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><blockquote>
<p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令，如下所示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET dir</span><br><span class="line"> &quot;dir&quot;</span><br><span class="line"> &quot;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&quot;</span><br></pre></td></tr></table></figure>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><blockquote>
<p>适合大规模的数据恢复<br>对数据完整性和一致性要求不高</p>
</blockquote>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><blockquote>
<p>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。<br>fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。</p>
</blockquote>
<h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><blockquote>
<p>动态所有停止RDB保存规则的方法：redis-cli config set save “”<br>即在配置文件中进行了一下修改<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304205359.png" alt=""></p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200304205629.png" alt=""></p>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><blockquote>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
</blockquote>
<h4 id="AOF的启动-恢复-修复"><a href="#AOF的启动-恢复-修复" class="headerlink" title="AOF的启动/恢复/修复"></a>AOF的启动/恢复/修复</h4><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><blockquote>
<p>AOF保存在apprndonly.aof文件中，配置位置在 /usr/local/bin目录下<br>修改  /myRedis中的conf文件<br>启动设置将conf文件中默认的appendonly no 改为 yes</p>
</blockquote>
<h5 id="正常恢复"><a href="#正常恢复" class="headerlink" title="正常恢复"></a>正常恢复</h5><blockquote>
<p>将有数据的aof文件复制一份保存到对应目录(config get dir)<br>恢复：重启redis然后重新加载</p>
</blockquote>
<h4 id="备份被写坏的AOF文件"><a href="#备份被写坏的AOF文件" class="headerlink" title="备份被写坏的AOF文件"></a>备份被写坏的AOF文件</h4><blockquote>
<p><code>redis-check-aof --fix  appendonli.aof</code>：在 /usr/local/bin/ 目录及redis安装目录下启动redis-check-aof –fix 进行修复aof文件。<br>恢复：重启redis然后重新加载</p>
</blockquote>
<h4 id="rewrit重写"><a href="#rewrit重写" class="headerlink" title="rewrit重写"></a>rewrit重写</h4><blockquote>
<p>重写原理：AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。<br>触发机制：Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。可见上文解析配置文件–&gt;APPEND ONLY MODE追加。</p>
</blockquote>
<h4 id="AOF优劣势"><a href="#AOF优劣势" class="headerlink" title="AOF优劣势"></a>AOF优劣势</h4><h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><blockquote>
<p>三种模式下：<br>每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好。（慢）<br>每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失。（折中）<br>不同步：appendfsync no   从不同步。（快）</p>
</blockquote>
<h5 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h5><blockquote>
<p>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb。<br>aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同。</p>
</blockquote>
<h4 id="AOF小结"><a href="#AOF小结" class="headerlink" title="AOF小结"></a>AOF小结</h4><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305103554.png" alt=""></p>
<h3 id="RDB和AOF总结"><a href="#RDB和AOF总结" class="headerlink" title="RDB和AOF总结"></a>RDB和AOF总结</h3><blockquote>
<p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。<br>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。<br>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p>
</blockquote>
<h4 id="同时开启两种持久化方式"><a href="#同时开启两种持久化方式" class="headerlink" title="同时开启两种持久化方式"></a>同时开启两种持久化方式</h4><blockquote>
<p>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。<br>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p>
</blockquote>
<h4 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h4><blockquote>
<p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。</p>
</blockquote>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><blockquote>
<p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：<br><code>事务是一个单独的隔离操作</code>：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br><code>事务是一个原子操作</code>：事务中的命令要么全部被执行，要么全部都不执行。<br>redis事务里面执行的操作都是入队的过程：<br>一个队列中，一次性、顺序性、排他性的执行一系列命令</p>
</blockquote>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><blockquote>
<p><code>MULTI 命令</code>用于开启一个事务，它总是返回 OK 。<br>MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是而是返回QUEUED,表示被放到一个队列中， 当 <code>EXEC</code>命令（执行命令）被调用时， 所有队列中的命令才会被执行。<br>另一方面， 通过调用 <code>DISCARD</code> ， 客户端可以清空事务队列， 并放弃<code>执行事务</code>。<br><code>全体连坐</code>：当事务开启后，客户端向服务器发送命令时，当执行一个错误命令没有成功入队（及没有返回QUEUEN），用EXEC触发并执行事务时，该队列中的所有命令都不会执行。（相当于Java中的编译期异常）<br><code>冤头债主</code>：当事务开启后，客户端向服务器发送命令时，当执行一个错误命令成功入队（返回QUEUEN），用EXEC触发并执行事务时，该队列中的所有命令除了异常命令外都将执行。（相当于Java中的运行期异常）。由此可以看出Redis在这里不支持事务，所以说Redis是部分支持事务。<br><code>WATCH</code>命令可以为 Redis 事务提供 check-and-set （CAS）行为。（注意：WATCH不能写在MULTI中）<br>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。<br>如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了监控的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。<br>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。<br>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。用户还可以在单个 WATCH 命令中监视任意多个键：WATCH key1 key2 key3。<br>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。<br>使用无参数的 <code>UNWATCH</code> 命令可以手动取消对所有键的监视。</p>
</blockquote>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote>
<p>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题。<br>不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</p>
</blockquote>
<h2 id="Redis的发布订阅"><a href="#Redis的发布订阅" class="headerlink" title="Redis的发布订阅"></a>Redis的发布订阅</h2><blockquote>
<p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。<br>先订阅后发布后才能收到消息：<br>1 可以一次性订阅多个，SUBSCRIBE c1 c2 c3；<br>2 消息发布，PUBLISH c2 hello-redis；<br>3 订阅多个，通配符<em>， PSUBSCRIBE new</em>；<br>4 收取消息， PUBLISH HelloWorld。</p>
</blockquote>
<h2 id="Redis的主从复制（Master-Slave）"><a href="#Redis的主从复制（Master-Slave）" class="headerlink" title="Redis的主从复制（Master/Slave）"></a>Redis的主从复制（Master/Slave）</h2><blockquote>
<p>我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主。<br>可以实现：读写分离，容灾备份。</p>
</blockquote>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li><p>配从不配主<br>在多个服务器中，要指定主从关系只需要在从库中配置关系。</p>
</li>
<li><p>从库配置<br>slaveof 主库IP 主库端口<br>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件。</p>
</li>
<li><p>修改配置细节操作</p>
<blockquote>
<ol>
<li>拷贝多个redis.conf文件。</li>
<li>开启daemonize yes。</li>
<li>pid文件名字。</li>
<li>指定端口</li>
<li>log文件名字。</li>
<li>dump.rdb名字<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305172834.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305172638.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305172724.png" alt=""><br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305172803.png" alt=""></li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><p>一个Master两个Slave<br> <code>info replication</code>：查看日志。</p>
<blockquote>
<p>主从问题： </p>
<ol>
<li>主机set的数据，从机都可以get到。</li>
<li>从机只能读，无法写。</li>
<li>主机shutdown后，从机原地待命。</li>
<li>主机又回来了后，主机新增记录，从机还能顺利复制</li>
<li>从机down后都需要重新连接，除非你配置进redis.conf文件。</li>
</ol>
</blockquote>
<h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><blockquote>
<p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master，可以有效减轻master的写压力。<br>中途变更转向:会清除之前的数据，重新建立拷贝最新的。<br><code>slaveof 新主库IP 新主库端口</code></p>
</blockquote>
<ul>
<li>反客为主<blockquote>
<p>若主机关闭，从机要变成主机直接  <code>SLAVEOF no one</code></p>
</blockquote>
</li>
</ul>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><blockquote>
<p>slave启动成功连接到master后会发送一个sync命令。<br>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步。<br>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。<br>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。<br>但是只要是重新连接master,一次完全同步（全量复制）将被自动执行。</p>
</blockquote>
<h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a>哨兵模式(sentinel)</h3><blockquote>
<p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
</blockquote>
<blockquote>
<ol>
<li>自定义的/myRedis目录下新建sentinel.conf文件，名字绝不能错。<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305180725.png" alt=""></li>
<li>sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1。<br>上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机。<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305181235.png" alt=""></li>
<li>redis-sentinel /myredis/sentinel.conf<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305181408.png" alt=""></li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>当master挂掉后，哨兵模式将启动投票模式选出一个主机。之前的master重启回来后哨兵模式再次启动将它变成新主机下的从机。<br><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305182744.png" alt=""></li>
</ol>
</blockquote>
<h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><blockquote>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
</blockquote>
<h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h2><h3 id="客户端上基本配置及使用："><a href="#客户端上基本配置及使用：" class="headerlink" title="客户端上基本配置及使用："></a>客户端上基本配置及使用：</h3><ol>
<li>配置Java环境，创建项目，导入jar包如下图：</li>
</ol>
<p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305190335.png" alt=""></p>
<ol start="2">
<li>服务器端需要在防火墙中放行Redis端口6379</li>
</ol>
<blockquote>
<p><code>service iptables status</code>：查看是否放行端口。<br><code>iptables -I INPUT -p tcp --dport 6379 -j ACCEPT</code>：放行端口。<br><code>service iptables save</code>：保存端口。<br><code>service iptables rstatus</code>：重启Redis。</p>
</blockquote>
<ol start="3">
<li>idea中用Redis</li>
</ol>
<p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305191216.png" alt=""></p>
<h3 id="事务提交基本使用："><a href="#事务提交基本使用：" class="headerlink" title="事务提交基本使用："></a>事务提交基本使用：</h3><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305192002.png" alt=""></p>
<h3 id="主从复制："><a href="#主从复制：" class="headerlink" title="主从复制："></a>主从复制：</h3><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305193418.png" alt=""></p>
<h3 id="JedisPool"><a href="#JedisPool" class="headerlink" title="JedisPool"></a>JedisPool</h3><h4 id="配置连接池："><a href="#配置连接池：" class="headerlink" title="配置连接池："></a>配置连接池：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JedisUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedisInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (jedisPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisUtils<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (jedisPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">                    jedisPoolConfig.setMaxActive(<span class="number">10000</span>);</span><br><span class="line">                    jedisPoolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    jedisPoolConfig.setMaxWait(<span class="number">3000</span>);</span><br><span class="line">                    jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">                    jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, <span class="string">"192.168.74.129"</span>, <span class="number">6379</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        jedisPool.returnResourceObject(jedis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p><img src="https://gitee.com/bin1018/MaYunImages/raw/master/img/20200305195438.png" alt=""></p>
<h4 id="配置参数："><a href="#配置参数：" class="headerlink" title="配置参数："></a>配置参数：</h4><blockquote>
<p>JedisPool的配置参数大部分是由JedisPoolConfig的对应项来赋值的。<br><code>maxActive</code>：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted。<br><code>maxIdle</code>：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；<br>whenExhaustedAction：表示当pool中的jedis实例都被allocated完时，pool要采取的操作；默认有三种。 WHEN_EXHAUSTED_FAIL –&gt; 表示无jedis实例时，直接抛出NoSuchElementException； WHEN_EXHAUSTED_BLOCK –&gt; 则表示阻塞住，或者达到maxWait时抛出JedisConnectionException； WHEN_EXHAUSTED_GROW –&gt; 则表示新建一个jedis实例，也就说设置的maxActive无用；<br><code>maxWait</code>：表示当borrow一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛JedisConnectionException；testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；testOnReturn：return 一个jedis实例给pool时，是否检查连接可用性（ping()）；testWhileIdle：如果为true，表示有一个idle object evitor线程对idle object进行扫描，如果validate失败，此object会被从pool中drop掉；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；timeBetweenEvictionRunsMillis：表示idle object evitor两次扫描之间要sleep的毫秒数；numTestsPerEvictionRun：表示idle object evitor每次扫描的最多的对象数；minEvictableIdleTimeMillis：表示一个对象至少停留在idle状态的最短时间，然后才能被idle object evitor扫描并驱逐；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；softMinEvictableIdleTimeMillis：在minEvictableIdleTimeMillis基础上，加入了至少minIdle个对象已经在pool里面了。如果为-1，evicted不会根据idle time驱逐任何对象。如果minEvictableIdleTimeMillis&gt;0，则此项设置无意义，且只有在timeBetweenEvictionRunsMillis大于0时才有意义；<br><code>lifo</code>：borrowObject返回对象时，是采用DEFAULT_LIFO（last in first out，即类似cache的最频繁使用队列），如果为False，则表示FIFO队列；</p>
</blockquote>
<p><code>其中JedisPoolConfig对一些参数的默认设置如下：</code><br>testWhileIdle=true<br>minEvictableIdleTimeMills=60000<br>timeBetweenEvictionRunsMillis=30000<br>numTestsPerEvictionRun=-1</p>
]]></content>
      <categories>
        <category>NoSql</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSql</tag>
      </tags>
  </entry>
</search>
